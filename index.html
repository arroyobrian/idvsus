<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Parallelizing Efros-Freeman Image Quilting Algorithm</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Parallelizing Efros-Freeman Image Quilting Algorithm</h1>
        <p>A CS205 Fall 2015 Final Project</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/aidizhang/leapday" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/aidizhang/leapday/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/aidizhang/leapday/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>
<a id="welcome-to-pages" class="anchor" href="#welcome-to-pages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview of Project</h1>

<p>Here is a video about our work:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/aONJ4fhUXsg" frameborder="0" allowfullscreen></iframe>

<h2>
<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span class="octicon octicon-link"></span></a>Motivation</h2>

<p>The Efros-Freeman image quilting algorithm is designed to solve the texture synthesis problem, which takes an input image and generates an arbitrarily large image of the same texture. This generated images can be used in a variety of contexts, most obviously with computer generated graphics for television and movie media. This is better than just simply tiling input texture because we can handle stochastic textures, and because the output textures are not identical to the human eye.</p>

<h2>
<a id="what-will-code-look-like" class="anchor" href="#what-will-code-look-like" aria-hidden="true"><span class="octicon octicon-link"></span></a>Serial Design</h2>

<p>The original Efros-Freeman algorithm works by going through our target image in raster scan order in steps of one block. For every block, we search the input sample for blocks that satisfy overlap constraints within some error tolerance. This means that we randomly choose a candidate patch with a sufficiently low overlap error. A higher error tolerance means that overlapping patches might not be as well fitted together whereas a lower error tolerance increases the chances of growing garbage, hence this is a tradeoff. Overlap errors were calculated using L2 norm of a pixel-wise vector across the number channels (3 for RGB-colored images).</p>

<h2>
<a id="sub-nav-questions" class="anchor" href="#sub-nav-questions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parallelism</h2>

<p>There are 3 phases of the Efros-Freeman algorithm in which we can exploit parallelism:</p>

<ul>
<li>Searching for candidate patches: This is essentially an “embarrassingly parallel” problem since we are not writing to shared memory, and threads never access the same part of shared memory. 
</li>
<li>Parallelizing dynamic programming: Filling in the dynamic programming table has potential for improvements via parallelism. However, since our overlap sizes are usually not that large, scheduling overhead might override any potential benefits from parallelism. The theory behind this though …
</li>
<li>Insertion of patches into the generated texture: This comprises the brunt of the work of the algorithm, and is not easy to parallelize because overlapping areas are being read from and written to, hence each patch depends on previous patches having been finalized. The way this problem might be approached is using locks with condition variables to schedule threads to insert patches such that it is ensured that the current patch’s dependent patches to the up and left have been inserted.
</li>
</ul>

<h2>
<a id="whos-this-matt-graham" class="anchor" href="#whos-this-matt-graham" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance</h2>

<h2>
<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span class="octicon octicon-link"></span></a>Results</h2>

<p>The serial implementation of the algorithm gives us surprisingly good results for a wide range of textures. Here are some examples:

In some of them, for example the pebbles on this slide, the jagged edge is clearly visible.</p>

<h2>
<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span class="octicon octicon-link"></span></a>Further Work and Remarks</h2>



      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/aidizhang">aidizhang</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
